From a7eed17a0b2a1c09ef986f3b4b323cd31cea2b64 Mon Sep 17 00:00:00 2001
From: Werner Koch <wk@gnupg.org>
Date: Tue, 3 May 2016 14:10:04 +0200
Subject: [PATCH] Fix possible read access beyond the buffer.

* src/ber-help.c (_ksba_ber_parse_tl): Add extra sanity check.
* src/cert.c (ksba_cert_get_cert_policies): Check TLV given length
against buffer length.
(ksba_cert_get_ext_key_usages): Ditto.
* src/ocsp.c (parse_asntime_into_isotime): Ditto.
--

The returned length of the object from _ksba_ber_parse_tl (ti.length)
was not always checked against the actual buffer length, thus leading
to a read access after the end of the buffer and thus a segv.

GnuPG-bug-id: 2344
Reported-by: Pascal Cuoq
Signed-off-by: Werner Koch <wk@gnupg.org>
---
 src/ber-help.c |  6 ++++++
 src/cert.c     | 23 ++++++++++++++++++++++-
 src/name.c     |  2 +-
 src/ocsp.c     |  2 ++
 4 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/src/ber-help.c b/src/ber-help.c
index f6a6692..87109f3 100644
--- a/src/ber-help.c
+++ b/src/ber-help.c
@@ -285,9 +285,15 @@ _ksba_ber_parse_tl (unsigned char const **buffer, size_t *size,
           ti->buf[ti->nhdr++] = c;
           len |= c & 0xff;
         }
+      /* Sanity check for the length: This is done so that we can take
+       * the value for malloc plus some additional bytes without
+       * risking an overflow.  */
+      if (len > (1 << 30))
+        return gpg_error (GPG_ERR_BAD_BER);
       ti->length = len;
     }
 
+
   /* Without this kludge some example certs can't be parsed */
   if (ti->class == CLASS_UNIVERSAL && !ti->tag)
     ti->length = 0;
diff --git a/src/cert.c b/src/cert.c
index 7f19dc1..f3ff6a1 100644
--- a/src/cert.c
+++ b/src/cert.c
@@ -1335,9 +1335,15 @@ ksba_cert_get_cert_policies (ksba_cert_t cert, char **r_policies)
                   err = gpg_error (GPG_ERR_NOT_DER_ENCODED);
                   goto leave;
                 }
+              if (ti.length > derlen)
+                {
+                  err = gpg_error (GPG_ERR_BAD_BER);
+                  goto leave;
+                }
               if (!ti.length)
                 {
-                  err = gpg_error (GPG_ERR_INV_CERT_OBJ); /* no empty inner SEQ */
+                  /* We do not accept an empty inner SEQ */
+                  err = gpg_error (GPG_ERR_INV_CERT_OBJ);
                   goto leave;
                 }
               if (ti.nhdr+ti.length > seqlen)
@@ -1356,6 +1362,11 @@ ksba_cert_get_cert_policies (ksba_cert_t cert, char **r_policies)
                   err = gpg_error (GPG_ERR_INV_CERT_OBJ);
                   goto leave;
                 }
+              if (ti.length > derlen)
+                {
+                  err = gpg_error (GPG_ERR_BAD_BER);
+                  goto leave;
+                }
               if (ti.nhdr+ti.length > seqseqlen)
                 {
                   err = gpg_error (GPG_ERR_BAD_BER);
@@ -1458,6 +1469,16 @@ ksba_cert_get_ext_key_usages (ksba_cert_t cert, char **result)
                   err = gpg_error (GPG_ERR_INV_CERT_OBJ);
                   goto leave;
                 }
+              if (ti.ndef)
+                {
+                  err = gpg_error (GPG_ERR_NOT_DER_ENCODED);
+                  goto leave;
+                }
+              if (ti.length > derlen)
+                {
+                  err = gpg_error (GPG_ERR_BAD_BER);
+                  goto leave;
+                }
 
               suboid = ksba_oid_to_str (der, ti.length);
               if (!suboid)
diff --git a/src/name.c b/src/name.c
index c734199..371fc41 100644
--- a/src/name.c
+++ b/src/name.c
@@ -113,7 +113,7 @@ _ksba_name_new_from_der (ksba_name_t *r_name,
 
   *r_name = NULL;
 
-  /* count and check for encoding errors - we won;t do this again
+  /* Count and check for encoding errors - we won't do this again
      during the second pass */
   der = image;
   derlen = imagelen;
diff --git a/src/ocsp.c b/src/ocsp.c
index 85679bb..c053b18 100644
--- a/src/ocsp.c
+++ b/src/ocsp.c
@@ -231,6 +231,8 @@ parse_asntime_into_isotime (unsigned char const **buf, size_t *len,
               && (ti.tag == TYPE_UTC_TIME || ti.tag == TYPE_GENERALIZED_TIME)
               && !ti.is_constructed) )
     err = gpg_error (GPG_ERR_INV_OBJ);
+  else if (ti.length > *len)
+    err = gpg_error (GPG_ERR_INV_BER);
   else if (!(err = _ksba_asntime_to_iso (*buf, ti.length,
                                          ti.tag == TYPE_UTC_TIME, isotime)))
     parse_skip (buf, len, &ti);
-- 
2.8.1

